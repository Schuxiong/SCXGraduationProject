# 游戏对局结束功能接口说明

## 概述

本文档详细介绍象棋游戏中各种对局结束方式的接口调用方法，包括：

- **投降功能**：玩家主动投降退出游戏
- **和棋功能**：玩家发起和棋请求，对方同意后游戏结束
- **超时流局**：游戏因超时而结束
- **正常结束**：通过将军、将死等正常象棋规则结束

## 4. 正常结束

正常结束是指通过象棋规则（如将死、困毙等）自然结束的对局。当玩家通过行棋接口吃掉对方的王时，系统会自动检测并结束游戏。

### 4.1 触发方式

正常结束通过现有的行棋接口自动触发：

**接口地址：** `POST /game/chessMove/move`

**触发条件：** 当玩家移动棋子吃掉对方的王（king）时

**自动处理逻辑：**
1. 系统检测到王被吃掉
2. 自动调用游戏结束处理逻辑
3. 更新游戏状态为正常结束（状态码：2）
4. 更新玩家积分（胜方+30分，负方-30分）
5. 通过WebSocket发送游戏结束通知

### 4.2 WebSocket通知

```json
{
  "type": "GAME_OVER",
  "payload": {
    "winner": "BLACK", // 或 "WHITE"
    "reason": "CHECKMATE",
    "gameId": "游戏ID"
  }
}
```

## 游戏状态说明

| 状态码 | 状态描述 | 说明 |
|--------|----------|------|
| 1 | 游戏进行中 | 游戏正在进行，可以继续下棋 |
| 2 | 正常结束 | 通过象棋规则正常结束（将死、困毙等） |
| 3 | 黑方胜利 | 黑方获胜 |
| 4 | 白方胜利 | 白方获胜 |
| 5 | 和棋 | 双方同意和棋 |
| 6 | 超时流局 | 因超时导致的流局 |
| 7 | 黑方退出 | 黑方投降退出 |
| 8 | 白方退出 | 白方投降退出 |

## 接口详情

### 1. 投降功能

#### 接口地址
```
POST /api/game/chessGame/quit/{gameId}
```

#### 请求参数
- `gameId`（路径参数）：游戏ID，必填

#### 请求头
- `Authorization`：Bearer token，用户认证令牌

#### 响应示例

**成功响应：**
```json
{
  "success": true,
  "message": "操作成功",
  "code": 200,
  "result": "您已退出游戏",
  "timestamp": 1685779200000
}
```

**失败响应：**
```json
{
  "success": false,
  "message": "游戏已结束，无法退出",
  "code": 500,
  "result": null,
  "timestamp": 1685779200000
}
```

#### 业务逻辑
1. 验证游戏是否存在且正在进行中（状态1）
2. 验证用户是否为游戏参与者（黑方或白方）
3. 根据投降方更新游戏状态：
   - 黑方投降：游戏状态设为7，白方获胜
   - 白方投降：游戏状态设为8，黑方获胜
4. 通过WebSocket通知对方玩家游戏结束

#### WebSocket通知消息
```json
{
  "type": "game_quit",
  "gameId": "game123",
  "quitPlayer": "player1",
  "winner": "player2",
  "gameState": 7,
  "message": "player1 已退出游戏，player2 获胜"
}
```

### 2. 和棋功能

#### 2.1 发起和棋请求

**接口地址：**
```
POST /api/game/chessGame/draw/request/{gameId}
```

**请求参数：**
- `gameId`（路径参数）：游戏ID，必填

**请求头：**
- `Authorization`：Bearer token，用户认证令牌

**响应示例：**
```json
{
  "success": true,
  "message": "和棋请求已发送",
  "code": 200,
  "result": "和棋请求已发送",
  "timestamp": 1685779200000
}
```

#### 2.2 响应和棋请求

**接口地址：**
```
POST /api/game/chessGame/draw/respond/{gameId}
```

**请求参数：**
- `gameId`（路径参数）：游戏ID，必填

**请求体：**
```json
{
  "accept": true  // true表示接受，false表示拒绝
}
```

**响应示例（接受）：**
```json
{
  "success": true,
  "message": "和棋请求已接受，游戏结束",
  "code": 200,
  "result": "和棋请求已接受，游戏结束",
  "timestamp": 1685779200000
}
```

**响应示例（拒绝）：**
```json
{
  "success": true,
  "message": "和棋请求已拒绝",
  "code": 200,
  "result": "和棋请求已拒绝",
  "timestamp": 1685779200000
}
```

#### 2.3 获取和棋请求状态

**接口地址：**
```
GET /api/game/chessGame/draw/status/{gameId}
```

**响应示例：**
```json
{
  "success": true,
  "message": "操作成功",
  "code": 200,
  "result": {
    "id": "draw123",
    "gameId": "game123",
    "requestUserId": "user1",
    "requestUserAccount": "player1",
    "targetUserId": "user2",
    "targetUserAccount": "player2",
    "status": 1,
    "createTime": "2023-06-03 15:30:00"
  },
  "timestamp": 1685779200000
}
```

#### 2.4 取消和棋请求

**接口地址：**
```
DELETE /api/game/chessGame/draw/cancel/{gameId}
```

**响应示例：**
```json
{
  "success": true,
  "message": "和棋请求已取消",
  "code": 200,
  "result": "和棋请求已取消",
  "timestamp": 1685779200000
}
```

### 3. 超时流局功能

#### 接口地址
```
POST /api/game/chessGame/timeout/{gameId}
```

#### 请求参数
- `gameId`（路径参数）：游戏ID，必填

#### 请求头
- `Authorization`：Bearer token，用户认证令牌

#### 响应示例

**成功响应：**
```json
{
  "success": true,
  "message": "操作成功",
  "code": 200,
  "result": "游戏已标记为超时流局",
  "timestamp": 1685779200000
}
```

**失败响应：**
```json
{
  "success": false,
  "message": "游戏已结束，无法处理超时",
  "code": 500,
  "result": null,
  "timestamp": 1685779200000
}
```

#### 业务逻辑
1. 验证游戏是否存在且正在进行中（状态1）
2. 更新游戏状态为6（超时流局）
3. 通过WebSocket通知双方玩家游戏超时结束

#### WebSocket通知消息
```json
{
  "type": "game_timeout",
  "gameId": "game123",
  "message": "游戏超时，流局",
  "gameState": 6
}
```

## 前端调用示例

### JavaScript/TypeScript 示例

```javascript
// 获取认证token
function getToken() {
  return localStorage.getItem('token');
}

// 投降功能
async function quitGame(gameId) {
  if (!confirm('确定要投降吗？投降后游戏将立即结束。')) {
    return;
  }
  
  try {
    const response = await fetch(`/api/game/chessGame/quit/${gameId}`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${getToken()}`,
        'Content-Type': 'application/json'
      }
    });
    
    const result = await response.json();
    if (result.success) {
      console.log('投降成功，游戏结束');
      alert(result.result);
      // 更新游戏状态，跳转到结果页面等
    } else {
      console.error('投降失败：', result.message);
      alert(result.message);
    }
  } catch (error) {
    console.error('投降请求失败：', error);
    alert('投降请求失败');
  }
}

// 发起和棋请求
async function requestDraw(gameId) {
  try {
    const response = await fetch(`/api/game/chessGame/draw/request/${gameId}`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${getToken()}`,
        'Content-Type': 'application/json'
      }
    });
    
    const result = await response.json();
    if (result.success) {
      console.log('和棋请求已发送');
      alert(result.result);
    } else {
      console.error('发送和棋请求失败：', result.message);
      alert(result.message);
    }
  } catch (error) {
    console.error('发送和棋请求失败：', error);
    alert('发送和棋请求失败');
  }
}

// 行棋功能（包含正常结束检测）
async function makeMove(gameId, moveData) {
  try {
    const response = await fetch('/game/chessMove/move', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${getToken()}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        chessGameId: gameId,
        chessPiecesId: moveData.pieceId,
        toPositionX: moveData.toX,
        toPositionY: moveData.toY,
        ...moveData
      })
    });
    
    const result = await response.json();
    if (result.success) {
      // 行棋成功，如果吃掉对方的王，后端会自动处理游戏结束
      console.log('行棋成功');
      return result.result;
    } else {
      alert('行棋失败：' + result.message);
    }
  } catch (error) {
    console.error('行棋请求失败:', error);
  }
}

// 响应和棋请求
async function respondDraw(gameId, accept) {
  try {
    const response = await fetch(`/api/game/chessGame/draw/respond/${gameId}`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${getToken()}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ accept })
    });
    
    const result = await response.json();
    if (result.success) {
      console.log(accept ? '已接受和棋' : '已拒绝和棋');
      alert(result.result);
      if (accept) {
        // 游戏结束，更新UI状态
      }
    } else {
      console.error('响应和棋请求失败：', result.message);
      alert(result.message);
    }
  } catch (error) {
    console.error('响应和棋请求失败：', error);
    alert('响应和棋请求失败');
  }
}

// 处理游戏超时
async function handleGameTimeout(gameId) {
  try {
    const response = await fetch(`/api/game/chessGame/timeout/${gameId}`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${getToken()}`,
        'Content-Type': 'application/json'
      }
    });
    
    const result = await response.json();
    if (result.success) {
      console.log('游戏已标记为超时流局');
      // 更新游戏状态
    } else {
      console.error('处理超时失败：', result.message);
    }
  } catch (error) {
    console.error('处理超时请求失败：', error);
  }
}
```

### Vue.js 组合式API 示例

```vue
<template>
  <div class="game-controls">
    <!-- 投降按钮 -->
    <button 
      @click="quitGame" 
      :disabled="quitting || gameEnded"
      class="quit-btn"
    >
      {{ quitting ? '投降中...' : '投降' }}
    </button>
    
    <!-- 和棋相关按钮 -->
    <div v-if="!gameEnded">
      <button 
        v-if="!drawRequest" 
        @click="requestDraw" 
        :disabled="requesting"
        class="draw-btn"
      >
        {{ requesting ? '发送中...' : '请求和棋' }}
      </button>
      
      <div v-if="drawRequest && drawRequest.targetUserId === currentUserId">
        <button @click="respondDraw(true)" :disabled="responding">接受和棋</button>
        <button @click="respondDraw(false)" :disabled="responding">拒绝和棋</button>
      </div>
      
      <div v-if="drawRequest && drawRequest.requestUserId === currentUserId">
        <span>等待对方响应和棋请求...</span>
        <button @click="cancelDrawRequest" :disabled="cancelling">取消请求</button>
      </div>
    </div>
    
    <!-- 行棋按钮（示例） -->
    <button 
      @click="makeMove" 
      :disabled="moving || gameEnded"
      class="move-btn"
    >
      {{ moving ? '行棋中...' : '行棋' }}
    </button>
    
    <!-- 游戏结束状态显示 -->
    <div v-if="gameEnded" class="game-end-status">
      <p>{{ gameEndMessage }}</p>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, onUnmounted } from 'vue'

const props = defineProps({
  gameId: String,
  currentUserId: String
})

// 响应式数据
const quitting = ref(false)
const requesting = ref(false)
const responding = ref(false)
const cancelling = ref(false)
const moving = ref(false)
const gameEnded = ref(false)
const gameEndMessage = ref('')
const drawRequest = ref(null)

// 投降功能
const quitGame = async () => {
  if (!confirm('确定要投降吗？投降后游戏将立即结束。')) {
    return
  }
  
  quitting.value = true
  try {
    const response = await fetch(`/api/game/chessGame/quit/${props.gameId}`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${getToken()}`
      }
    })
    
    const result = await response.json()
    if (result.success) {
      console.log('投降成功，游戏结束')
      alert(result.result)
      gameEnded.value = true
    } else {
      console.error('投降失败：', result.message)
      alert(result.message)
    }
  } catch (error) {
    console.error('投降请求失败：', error)
    alert('投降请求失败')
  } finally {
    quitting.value = false
  }
}

// 行棋功能（包含正常结束检测）
const makeMove = async (moveData) => {
  moving.value = true
  try {
    const response = await fetch('/game/chessMove/move', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${getToken()}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        chessGameId: props.gameId,
        chessPiecesId: moveData.pieceId,
        toPositionX: moveData.toX,
        toPositionY: moveData.toY,
        ...moveData
      })
    })
    
    const result = await response.json()
    if (result.success) {
      // 行棋成功，如果吃掉对方的王，后端会自动处理游戏结束
      console.log('行棋成功')
      return result.result
    } else {
      alert('行棋失败：' + result.message)
    }
  } catch (error) {
    console.error('行棋请求失败:', error)
  } finally {
    moving.value = false
  }
}

// 发起和棋请求
const requestDraw = async () => {
  requesting.value = true
  try {
    const response = await fetch(`/api/game/chessGame/draw/request/${props.gameId}`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${getToken()}`
      }
    })
    
    const result = await response.json()
    if (result.success) {
      console.log('和棋请求已发送')
      alert(result.result)
      getDrawStatus() // 刷新和棋请求状态
    } else {
      console.error('发送和棋请求失败：', result.message)
      alert(result.message)
    }
  } catch (error) {
    console.error('发送和棋请求失败：', error)
    alert('发送和棋请求失败')
  } finally {
    requesting.value = false
  }
}

// 响应和棋请求
const respondDraw = async (accept) => {
  responding.value = true
  try {
    const response = await fetch(`/api/game/chessGame/draw/respond/${props.gameId}`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${getToken()}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ accept })
    })
    
    const result = await response.json()
    if (result.success) {
      console.log(accept ? '已接受和棋' : '已拒绝和棋')
      alert(result.result)
      if (accept) {
        gameEnded.value = true
      }
      drawRequest.value = null
    } else {
      console.error('响应和棋请求失败：', result.message)
      alert(result.message)
    }
  } catch (error) {
    console.error('响应和棋请求失败：', error)
    alert('响应和棋请求失败')
  } finally {
    responding.value = false
  }
}

// 取消和棋请求
const cancelDrawRequest = async () => {
  cancelling.value = true
  try {
    const response = await fetch(`/api/game/chessGame/draw/cancel/${props.gameId}`, {
      method: 'DELETE',
      headers: {
        'Authorization': `Bearer ${getToken()}`
      }
    })
    
    const result = await response.json()
    if (result.success) {
      console.log('和棋请求已取消')
      alert(result.result)
      drawRequest.value = null
    } else {
      console.error('取消和棋请求失败：', result.message)
      alert(result.message)
    }
  } catch (error) {
    console.error('取消和棋请求失败：', error)
    alert('取消和棋请求失败')
  } finally {
    cancelling.value = false
  }
}

// 获取和棋请求状态
const getDrawStatus = async () => {
  try {
    const response = await fetch(`/api/game/chessGame/draw/status/${props.gameId}`, {
      headers: {
        'Authorization': `Bearer ${getToken()}`
      }
    })
    
    const result = await response.json()
    if (result.success) {
      drawRequest.value = result.result
    }
  } catch (error) {
    console.error('获取和棋请求状态失败：', error)
  }
}

// WebSocket消息处理
const handleWebSocketMessage = (message) => {
  if (message.gameId !== props.gameId) return
  
  switch (message.type) {
    case 'GAME_OVER':
      // 处理游戏正常结束
      gameEnded.value = true
      const winner = message.payload.winner
      const reason = message.payload.reason
      if (reason === 'CHECKMATE') {
        gameEndMessage.value = `游戏结束！${winner === 'BLACK' ? '黑方' : '白方'}获胜（将死）`
      } else {
        gameEndMessage.value = `游戏结束！${winner === 'BLACK' ? '黑方' : '白方'}获胜`
      }
      // 清除和棋请求状态
      drawRequest.value = null
      break
    case 'game_quit':
      // 玩家投降退出游戏
      drawRequest.value = null
      gameEnded.value = true
      gameEndMessage.value = `${message.quitPlayer} 已投降，${message.winner} 获胜`
      alert(`${message.quitPlayer} 已投降，${message.winner} 获胜`)
      break
    case 'game_timeout':
      // 游戏超时流局
      drawRequest.value = null
      gameEnded.value = true
      gameEndMessage.value = '游戏因超时结束（流局）'
      alert('游戏超时，流局')
      break
    case 'draw_request':
      // 收到和棋请求
      getDrawStatus()
      break
    case 'draw_accepted':
      // 和棋请求被接受
      drawRequest.value = null
      gameEnded.value = true
      gameEndMessage.value = '双方同意和棋'
      alert('和棋请求已被接受，游戏结束')
      break
    case 'draw_rejected':
      // 和棋请求被拒绝
      drawRequest.value = null
      alert('和棋请求被拒绝')
      break
    case 'draw_request_cancelled':
      // 和棋请求被取消
      drawRequest.value = null
      break
  }
}

// 获取认证token
function getToken() {
  return localStorage.getItem('token')
}

// 组件挂载时获取和棋状态
onMounted(() => {
  getDrawStatus()
  // 这里应该设置WebSocket监听
  // websocket.addEventListener('message', handleWebSocketMessage)
})

// 组件卸载时清理
onUnmounted(() => {
  // 清理WebSocket监听
  // websocket.removeEventListener('message', handleWebSocketMessage)
})
</script>

<style scoped>
.game-controls {
  display: flex;
  gap: 10px;
  margin: 20px 0;
}

.quit-btn {
  background-color: #ff4444;
  color: white;
  border: none;
  padding: 8px 16px;
  border-radius: 4px;
  cursor: pointer;
}

.quit-btn:disabled {
  background-color: #cccccc;
  cursor: not-allowed;
}

.draw-btn {
  background-color: #4CAF50;
  color: white;
  border: none;
  padding: 8px 16px;
  border-radius: 4px;
  cursor: pointer;
}

.draw-btn:disabled {
  background-color: #cccccc;
  cursor: not-allowed;
}
</style>
```

## WebSocket 消息类型

| 消息类型 | 描述 | 触发场景 |
|----------|------|----------|
| `game_quit` | 玩家投降 | 玩家调用投降接口 |
| `game_timeout` | 游戏超时 | 游戏因超时结束 |
| `draw_request` | 和棋请求 | 玩家发起和棋请求 |
| `draw_accepted` | 和棋被接受 | 玩家接受和棋请求 |
| `draw_rejected` | 和棋被拒绝 | 玩家拒绝和棋请求 |
| `draw_request_cancelled` | 和棋请求被取消 | 玩家取消和棋请求 |

## 注意事项

1. **认证要求**：所有接口都需要用户认证，请在请求头中包含有效的Authorization token
2. **游戏状态验证**：大部分操作只能在游戏进行中（状态1）时执行
3. **权限验证**：只有游戏的参与者（黑方或白方）才能执行相关操作
4. **WebSocket连接**：确保WebSocket连接正常，以接收实时的游戏状态更新
5. **错误处理**：妥善处理网络错误和业务错误，提供用户友好的错误提示
6. **用户体验**：
   - 投降操作建议添加二次确认，避免误操作
   - 和棋请求应显示清晰的状态和操作按钮
   - 游戏结束后及时更新UI状态，禁用相关操作按钮
7. **并发处理**：投降和和棋请求可能同时发生，需要妥善处理并发情况
8. **超时处理**：超时流局通常由系统自动触发，前端主要负责接收和显示结果
9. **正常结束检测**：游戏正常结束（吃王）是通过行棋接口自动检测的，无需额外调用
10. **积分更新**：正常结束时系统会自动更新玩家积分（胜方+30分，负方-30分）

## 常见错误码

| 错误信息 | 原因 | 解决方案 |
|----------|------|----------|
| "游戏ID不能为空" | 未提供gameId参数 | 确保传入有效的gameId |
| "指定的游戏不存在或已被删除" | 游戏不存在 | 检查gameId是否正确 |
| "游戏已结束，无法退出" | 游戏已结束 | 检查游戏状态，已结束的游戏无法操作 |
| "您不是该游戏的参与者" | 用户不是游戏玩家 | 确保用户是游戏的黑方或白方 |
| "当前没有待响应的和棋请求" | 没有和棋请求 | 先发起和棋请求或检查请求状态 |
| "您不能响应自己发起的和棋请求" | 自己响应自己的请求 | 只能响应对方发起的和棋请求 |

---

**文档版本：** v1.0  
**最后更新：** 2024-06-03  
**维护者：** 开发团队